\documentclass[runningheads]{llncs}

\input{settings}
\input{defs}

% Possilby remove for final version
%\pagestyle{plain}

\begin{document}
\title{The TypeDB Type System}

\author{TBD
% Jon Haël Brenas\inst{1} \and
% Rachid Echahed\inst{2}\orcidID{0000-0002-8535-8057} \and
% Martin Strecker\inst{3}\orcidID{0000-0001-9953-9871}
}
\institute{UPS \and
 CNRS and University of Grenoble, France
}
\maketitle

\begin{abstract}
Trying to understand the TypeDB type system.
\end{abstract}

\keywords{ TBD
% Automated Theorem Proving,
% Modal Logic,
% Graph Transformations,
% Program Verification
}

% REMOVE THE FOLLOWING FOR FINAL VERSION  !!!!
%\def\theHdefinition{\theHtheorem}

%----------------------------------------------------------------------


%----------------------------------------------------------------------
\section{Background}\label{sec:background}

The main sources of information are the following:

\begin{itemize}
\item the TypeDB documentation available on the
  web\footnote{\url{https://docs.vaticle.com/}},
  henceforth referenced as [DOC];
\item a video about knowledge
  graphs\footnote{\url{https://vaticle.com/use-cases/knowledge-graphs}},
  henceforth referenced as [KGV], or for a particular instant (minute, second)
  within this video as [KGV:min:sec] or simply [KGV:min]
\end{itemize}

When the documentation does not
provide a unique answer, we have conducted experiments with TypeDB to
investigate the effective system behavior, see \secref{sec:questions}.


%----------------------------------------------------------------------
\section{The Type System, Conceptually}\label{sec:type_system_conceptually}

The following gives an abstract account of the TypeDB type system.

%......................................................................
\subsection{Structural description}

We distinguish three levels of structural description:
\begin{itemize}
\item Kinds (\secref{sec:structure_kinds}) are predefined concepts of the meta-model
\item Types (\secref{sec:structure_types}) are user-definable entities of a DB
  schema. A type is of a kind.
\item Instances (\secref{sec:structure_instances}) are user-definable entities
  of a DB. An instance is of a type.
\end{itemize}

\subsubsection{Kinds}\label{sec:structure_kinds}

The meta-model is composed of the following elements which we refer to as
\emph{kinds}, also see [KGV:16]:
\begin{itemize}
\item Thing
\item Attribute
\item Entity
\item Relation
\item Role
\end{itemize}
In the following treatment, we ignore rules, which are also mentioned in the
meta-model.

In the meta-model:
\begin{itemize}
\item Attribute, Entity, Relation are related to Thing via a \texttt{sub}
  relation;
\item each of Entity, Attribute, Relation, Role is related to itself via a
  \texttt{sub} relation;
\item Thing is related to Attribute via an \texttt{owns} relation;
\item Relation is related to Role via a \texttt{relates} relation;
\item Thing is related to Role via a \texttt{plays} relation.
\end{itemize}


\paragraph{Kind rules}


$$
\infer{\Gamma \vdash kind(Attribute)}{}
\quad
\infer{\Gamma \vdash kind(Entity)}{}
\quad
\infer{\Gamma \vdash kind(Relation)}{}
\quad
\infer{\Gamma \vdash kind(Role)}{}
$$



\subsubsection{Types}\label{sec:structure_types}

In a schema definition (following the keyword \texttt{define}), new
(attribute; entity; relation; role) types are introduced with the keyword
\texttt{sub}. These subtype relations are gathered in a context. For a subtype
declaration, we write $T' \preceq T$ instead of \texttt{T' sub T}.

\paragraph{Well-formedness rules} The following rules define well-formedness
of a context. The function $names$ retrieves all the newly introduced names of
a context.\remms{TBD}

$$
  \infer{wf(\Gamma, E \preceq T)}{
  wf(\Gamma) & E \notin names(\Gamma)
}
$$


\paragraph{Judgement: Type is of a Kind (rule set~1)}
The following rules derive a judgement $\Gamma \vdash T: K$ saying that type
$T$ is of kind $K$, where $K$ is one of the four kinds of
\secref{sec:structure_kinds}. For example, one could derive: 
$person \preceq entity \vdash person: Entity$.

Base case:
$$
\infer{\Gamma \vdash \mathtt{attribute} : Attribute}{}
\quad
\infer{\Gamma \vdash \mathtt{entity} : Entity}{}
\quad
\infer{\Gamma \vdash \mathtt{relation} : Relation}{}
\quad
\infer{\Gamma \vdash \mathtt{role} : Role}{}
$$

Subtype:
$$
\infer{\Gamma, T' \preceq T \vdash T' : K}{
  wf(\Gamma, T' \preceq T) & \Gamma \vdash T : K 
}
$$

Weakening:
$$
\infer{\Gamma, \Gamma' \vdash T : K}{
  wf(\Gamma, \Gamma')
  & 
  \Gamma \vdash T : K
}
$$


\paragraph{Judgement: Type is of a Kind (rule set~2)}

One may doubt that \texttt{entity} is itself a type (and similarly for
\texttt{attribute} etc.), see the questions in
\secref{sec:questions_type_decls}.

Base case:
$$
\infer{\Gamma, T' \preceq K \vdash T' : K}{
  wf(\Gamma, T' \preceq K)  & kind(K)
}
$$

Subtype:
$$
\infer{\Gamma, T' \preceq T \vdash T' : K}{
  wf(\Gamma, T' \preceq T) & \Gamma \vdash T : K 
}
$$

Weakening:
$$
\infer{\Gamma, \Gamma' \vdash T : K}{
  wf(\Gamma, \Gamma')
  & 
  \Gamma \vdash T : K
}
$$


\subsubsection{Relations and Attributes}\label{sec:structure_rels_attribs}

The \texttt{relates} declarations seem redundant, possibly even in
contradiction with the \texttt{plays} declarations, see
\secref{sec:questions_rels_attribs}. They are ignored here; we only discuss
\texttt{plays} declarations.



\subsubsection{Instances}\label{sec:structure_instances}




%......................................................................
\subsection{Semantics}





%----------------------------------------------------------------------
\section{Open and Solved Questions}\label{sec:questions}

%......................................................................
\subsection{Type Declarations}\label{sec:questions_type_decls}


\begin{enumerate}
\item Is it possible to introduce the same name both as an entity and as a
  relation type, something like:

  \begin{alltt}
    Foo sub entity;
    Foo sub relation;
  \end{alltt}
  
\emph{Answer : It shows an error : Invalid Query Pattern : the type variable 'test' has multiple 'sub' constraints.	 }
	
	

	
\item Is the type hierarchy acyclic, or is it possible to have
  \begin{alltt}
    C1 sub C2;
    C2 sub C1;
  \end{alltt}

\emph{Answer : It shows an error : Invalid Type Write : there is a cyclic type hierarchy, which is not allowed: '[C2, C1]'. }  
  
  
  or to introduce a type several times, like
  \begin{alltt}
    C sub entity;
    C1 sub C;
    C2 sub C;
    D sub C1;
    D sub C2;
  \end{alltt}
  
\emph{Answer : It shows an error : Invalid Query Pattern : the type variable 'd' has multiple 'sub' constraints. }  

\item It is not clear whether \texttt{entity} is indeed a type or only a kind
  in the sense of \secref{sec:structure_kinds}. Syntactically, it does not
  seem possible to declare a relation that has \texttt{entity} as its domain.

  A similar question holds for \texttt{attribute}. Would it be possible to
  write the following?

  \begin{alltt}
  e sub entity,
    owns attribute;
  \end{alltt}

  Probably not, because (semantically) the attribute would not have an
  associated value. A follow-up question to this is if attribute definitions
  can have 0 or $\geq 2$ associated \texttt{value} declarations, such as in
  \begin{alltt}
    a sub attribute;
  \end{alltt}
  (without value),  or
  \begin{alltt}
    a sub attribute,
    value string,
    value long;
  \end{alltt}
  (with several incompatible value declarations).
  
  
\item Is it possible for different entities to own the same attribute ? 
Something like :

  \begin{alltt}
     ent1 sub entity,
       owns att1;
     	
     ent2 sub entity,
       owns att1;
    		
    	 att1 sub attribute,
       value string;
  \end{alltt}
  
\emph{Answer : It seems to work because it doesn't show any error. It also works using a relation related to this two entities, which owns this same attribute.  
}  
  
  
  
  
  
or have the same attribute of an entity for which it is a (sous-entité) :

\begin{alltt}
     ent1 sub entity,
       owns att1;
     	
     ent2 sub ent1,
       owns att1;
    		
    	 att1 sub attribute,
       value string;
  \end{alltt}
  
\emph{Answer : It doesn't work : Invalid Type Write: The attribute type 'att1' has been inherited or overridden, and cannot be redeclared as an attribute. }  





\item Is it possible to have :

  \begin{alltt}
     R1 sub relation,
     relates role1;
    
     R2 sub R1,
      relates role1;
      
    E1 sub entity,
    plays R1:role1;
    
    E2 sub E1,
    plays R2:role1;
  \end{alltt}
  
\emph{Answer : It doesn't work : Invalid Type Write: The role type 'role1' is already declared by a supertype of 'R2'.
}  

or to have

\begin{alltt}
     R1 sub relation,
     relates role1;
    
     R2 sub R1;
      
    E1 sub entity,
    plays R1:role1;
    
    E2 sub E1,
    plays R2:role1;
  \end{alltt}
  
\emph{Answer : It doesn't work : Invalid Type Write: The role type 'R1:role1' has been inherited or overridden, and cannot be redeclared.
}  


\end{enumerate}

\subsection{Relations and Attributes}\label{sec:questions_rels_attribs}

\paragraph{Redundancy / conflict} The \texttt{relates} declarations seem to be
redundant and possibly conflict with \texttt{plays} declarations. The
following questions try to clarify the situation.

\begin{enumerate}
\item Missing \texttt{relates} declaration: What happens if there is no
  \texttt{relates} declaration but the role is used in a \texttt{plays}
  clause, such as in the following, if there is no \texttt{relates role1}
  declaration?

  \begin{alltt}
rel1 sub relation;

ent1 sub entity,
  plays rel1:role1;
  \end{alltt}

\emph{Answer : It shows an error : Invalid Type Read: The type 'rel1:role1' does not exist. }


\item Contradictory \texttt{relates} and \texttt{plays} declarations: What
  happens if a role is used in conjunction with a relation for which it has
  not been declared, such as the following:

  \begin{alltt}
rel1 sub relation,
  relates role1;

rel2 sub relation,
  relates role2;

ent1 sub entity,
  plays rel2:role1;
  \end{alltt}

\emph{Answer : It seems to work because it doesn't show any error. }


\end{enumerate}

\paragraph{Refinement and overriding} of \texttt{plays} declarations. In the
following examples, we assume that all the required \texttt{relates}
declarations have been done, and only concentrate on the \texttt{plays}
declarations.

\begin{enumerate}
\item Is it possible to redeclare a role in two unrelated relations /
  entities? This would amount to \emph{overloading}.

  \begin{alltt}
rel1 sub relation,
     relates role1;
rel2 sub relation,
     relates role1;

ent1 sub entity,
  plays rel1:role1;

ent2 sub entity,
  plays rel2:role1;
  \end{alltt}
  
 
\emph{Answer : It seems to work because it doesn't show any error. }
 
\item Is it possible to redeclare a role? This would amount to
  \emph{overriding}. The following illustrates the case for two relations that
  are subrelations:
  
  \begin{alltt}
rel1 sub relation,
     relates role1;
rel2 sub rel1,
     relates role1;

ent1 sub entity,
  plays rel1:role1;

ent2 sub entity,
  plays rel2:role1;
  \end{alltt}

\emph{Answer : It shows an error : Invalid Type Write: The role type 'role1' is already declared by a supertype of 'rel2'. }
  

\end{enumerate}


%......................................................................
\subsection{Objects and Identities}

\begin{enumerate}
\item We have already tried out to create two entities having identical
  attributes but which become two distinct objects.

  The question is whether there are also multi-relations, i.e. two entities
  can be related by the same relation several times.
\end{enumerate}



\subsection{Rules}

To read data coming from Typedb rules, we have to add --infer true at the end of the read command : 
\begin{alltt}
transaction database-name data read --infer true
\end{alltt}


\begin{enumerate}
\item Is it possible to define a rule as :
\begin{alltt}
personne sub entity,
    plays vip:personne-role,
    owns salaire;
    
vip sub personne;

salaire sub attribute,
  value long;

rule est-vip:
when {
  \$p isa personne, has salaire \$s;
  \$s > 10000;
} then {
 \$p isa vip;
};
\end{alltt}

\emph{Answer : Probably not, because it shows an error : Rule 'est-vip' 'then' '\$p isa vip': must be exactly one attribute ownership, or exactly one relation.
So we can conclude that rules can only affect attributes or relations. }


\end{enumerate}


\section{How to use the TypeDB System in Windows 11}

\subsection{Using the terminal console}


\subsubsection{Opening the server}

\begin{itemize}
\item go to the right folder which contains the typedb.bat file ( example : typedb-all-windows-2.10.0/typedb-all-windows-2.10.0/ )
\item open the server : \begin{alltt}./typedb.bat server \end{alltt}
\item let that window opened in background
\end{itemize}

\subsubsection{Opening the console}
\begin{itemize}
\item open a new terminal, and go to the same folder as before
\item open the console :   \begin{alltt}./typedb.bat console\end{alltt}     
\end{itemize}

\subsubsection{Console commands}

Once the console is opened, we can type several commands to read or write informations about the databases. The console will allow us to communicate with the databases, so it is useful to know some of the most important orders we can use :

\begin{itemize}
\item to list the several databases existing in the server :    \begin{alltt}database list\end{alltt}       
\item to show us the schema of a particular database :    \begin{alltt}database schema nomBd\end{alltt}       
\item To quit the console :                        \begin{alltt}exit\end{alltt}  
\end{itemize}

  \subsubsection{Transactions}
We can also use this console to make transactions, which are a block we open, and that we can commit at the end only if the order we typed was possible to make. This allows us to make the command at once and in case of an error, avoid that only one part of the order is made.

\begin{enumerate}
\item Opening  the transaction\\
These transactions can be used in two modes : write or read. Also, we have to specify if we want to point to the schema or the data :

\begin{alltt}
transaction nomBd data write
transaction nomBd data read
transaction nomBd schema write
\end{alltt}       

\item Write the order we want to make in this transaction\\
We can type a request adapted to the mode we have chosen (for example for a read transaction, use a read request (match, get), or for a data write transaction, use an order which writes, modifies or deletes the data.) For more information about the different requests, see below in the part requests.\\

It can also be useful to know that we can use the ‘source’ command to avoid us to type the requests here in the terminal, using a file containing it : 
        source example/file.tql
It is mostly used to define the schema, in a schema write transaction.\\

\emph{Note : sometimes, after returning our order, nothing is happening. In that case we have to do a ctrl c.}\\

\item Commit the transaction
\begin{itemize}
\item In the write mode, it is very important not to forget to type commit after having returned our order. Else, even if our order didn’t show any error, nothing will be made.
\item In the read mode, to quit, ctrl c
\end{itemize}

\end{enumerate}


\subsection{Using the App}




































%----------------------------------------------------------------------
\bibliographystyle{splncs04}
\bibliography{main}

\end{document}

%%% Local Variables: 
%%% mode: latex 
%%% TeX-master: t
%%% coding: utf-8
%%% End: 
